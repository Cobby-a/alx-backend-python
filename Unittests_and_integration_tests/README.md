Unittests and Integration TestsProject OverviewThis project focuses on mastering advanced testing techniques in Python, particularly distinguishing between unit tests and integration tests, and utilizing powerful testing concepts like mocking, parameterization, and memoization. We use the built-in Python unittest framework and the parameterized library for comprehensive test creation.The primary goal is to write robust tests for a hypothetical GithubOrgClient that interacts with the GitHub API, ensuring that external dependencies are properly mocked to maintain the isolation and speed of unit tests.Learning ObjectivesAt the end of this project, you are expected to be able to explain the following concepts to anyone, without the help of Google:The difference between Unit Tests and Integration Tests.Common testing patterns such as Mocking, Parameterizations, and Fixtures.The concept and implementation of Memoization.RequirementsAll files will be interpreted/compiled on Ubuntu 18.04 LTS using python3 (version 3.7).The codebase must adhere to the pycodestyle style (version 2.5).All modules, classes, and functions must be properly documented.All functions and coroutines must be type-annotated.File StructureFileDescriptionKey Conceptsutils.pyCore utilities: nested map access (access_nested_map), JSON fetching (get_json), and memoization decorator (memoize).Memoization, Type Hinting, Error Handlingclient.pyThe main class: GithubOrgClient handles fetching organization and repository data from GitHub.Memoization, Properties, Static Methodsfixtures.pyContains TEST_PAYLOADâ€”mock data structures used for parameterized testing and mocking network responses.Fixtures, Mock Datatest_utils.pyUnit tests for functions in utils.py, focusing on access_nested_map.Unit Testing, Parameterization, assertRaisestest_client.pyUnit and integration tests for the GithubOrgClient class.Mocking (patch), Integration Testing, FixturesHow to Run TestsAll tests are implemented using the standard Python unittest module.To execute all tests in a specific file (e.g., test_utils.py):$ python3 -m unittest test_utils.py
To run all tests in the project directory:$ python3 -m unittest discover .
Core Testing Concepts1. Unit Testing vs. Integration TestingFeatureUnit TestIntegration TestScopeA single function or method (a "unit").A flow of data through multiple modules or components.GoalTo verify that the specific logic inside the function is correct, assuming external dependencies work.To verify that different parts of the system interact correctly with each other.External CallsMocked (replaced with dummy data/functions).Usually live (allowing the code to interact with databases, network, etc.).ExampleTesting access_nested_map with predefined maps and paths.Testing GithubOrgClient.public_repos using mocked API responses.2. MockingMocking is the practice of replacing objects that your code depends on with objects that simulate the behavior of the real objects. This is critical for unit testing:Isolation: Ensures that the unit test only tests the logic inside the function, not the external system (e.g., GitHub API).Speed: Tests run instantly without waiting for network latency.Control: Allows testing of error conditions (e.g., network failure, malformed data) that are hard to trigger in a real environment.The Python standard library unittest.mock is used for this purpose, typically via the @patch decorator or patch context manager.3. ParameterizationParameterization is the technique of running the same test logic multiple times with different input data and expected outputs.In this project, we use the parameterized library.It simplifies test maintenance and makes the test code concise and highly readable (as seen in test_utils.py).4. MemoizationMemoization is an optimization technique used to speed up computer programs by caching the results of expensive function calls and returning the cached result when the same inputs occur again.The @memoize decorator in utils.py implements this pattern.In client.py, it ensures that API calls like fetching the organization data (org) or repository list (repos_payload) are only made once, significantly improving performance for repeated access within the class instance.